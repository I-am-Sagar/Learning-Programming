## 1 - Understanding Java Environment

To fully understand Java, one must understand the reasons behind its creation, the forces that shaped it and the legacy it inherits. 

### 1.1 - The Pre-Java Times

The first modern programming language that shook the whole world was C, invented and first implemented by Dennis Ritchie in 1972 at Bell Labs. In the late 1970s and early 1980s, C became the dominant programming language and is still widely used today, especially in the embedded industry. But as the software size grew, the prodecural paradigm of C was unable to cope with the complexity. 

In 1979, Bjarne Stroustrup created the object-oriented version of C, _C with Classes,_ to resolve the above mentioned incapability of C. In 1983, it was renamed to C++ (++ being the increment operator, implying one step ahead of C). Till early 1990s, C++ took hold and for a breif moment, the programmers felt that they had finally found the perfect programming language. 

### 1.2 - The Creation and Rise of Java

In 1989, Tim Berners Lee created World Wide Web (WWW), which gave rise to the internet. By 1993, the web began to enter everyday use. Since many machines are connected together on the internet, there was a need for a platform-independent language. This is because at that time there were no advanced browsers and people used different softwares for different tasks. Each PC on the internet may have different processor, different hardware architecture or different operating system and we can't use the same software for every machine. So, we had to compile the C++ source code on every single machine on which we wanted to run our code. That's a time-consuming as well as an expensive way of handling the situation.

Finally in 1995, after 18 months of effort by James Gosling and his team, notably including Patrick Naughton, Chris Wrath, Ed Frank and Mike Sheridan, Java was created at Sun Microsystems Inc. Gosling made Java a platform-independent language with the philosophy of **_write once, run everywhere._** Intentionally, the creators of Java kept syntax very much similar to C++, because of its immense popularity and that made it easier for the programmers to switch from C++ to Java. 

Apart from making Java a platform-independent language, Java was designed to solve a certain set of problems of C++. Java enhanced and refined the object-oriented paradigm used by C++, added integrated support for multithreading, provided a library that simplified internet access, lesser bugs as it removed the support for pointers and direct memory access, etc.   

### 1.3 - But what made Java platform-independent?

The million dollar question at this point of time is that, _Why is C++ not a platform-independent language whereas Java is?_ 

C++ codes are compiled by g++ complier. This compiler converts the code to an executable. This executable contains the code in the binary form which CPU can fetch as it is, decode it easily and execute it. So when the machine will differ in architecture, the instructions will differ and the compiler will produce a different binary file. So the flow is, `c++ code -> g++ compiler -> executable file -> operating system -> hardware`. 

Java doesn't follow this flow and does something different. Java compiler doesn't produce an executable file. Instead it produces another file called _bytecode._ This bytecode file is sent to _Java Virtual Machine (JVM),_ a software running on the operating system. JVM is implemented differently for each different machine available. However, although the details of the JVM will differ from platform to platform, all can understand the same bytecode generated by compiling a particular Java program. JVM, based on how it is implemented, will accordingly generate instructions by interpreting the bytecode and finally those instructions run on the machine. So in this way, instead of implementing each and every software again and again, we are now only implementing a single software (JVM) again and again for every machine. The flow here is, `java code -> java compiler -> bytecode -> JVM -> instructions compatible with the machine -> operating system -> hardware`.  

In this way, by introducing the concept of not compiling upto binary form but stopping at an intermediary stage and then fowarding that bytecode file to another in-between software (JVM) which differs from machine to machine and generates the final instructions according to the machine, Java became a platform-independent language. 

<hr/>

Enough talking! Let's write our first Java code - The Hello World Program. 